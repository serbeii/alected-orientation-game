import Phaser from 'phaser';
import { Car } from '../Car';
import { RaceTemplate } from './RaceTemplate';
import { EventBus } from '../EventBus';

export default class FirstRace extends RaceTemplate {
	constructor() {
		super({ key: 'FirstRace' });
	}

	preload() {
		this.load.setPath('assets');
		this.load.image('tiles', 'map_1.png');
		this.load.tilemapTiledJSON('map1', 'map1.json');
	}

	override create() {
		const map = this.make.tilemap({ key: 'map1' });
		const tileset: Phaser.Tilemaps.Tileset | null = map.addTilesetImage(
			'map_1',
			'tiles',
		);

		// Create the layers
		if (!tileset) {
			return;
		}

		const groundLayer = map.createLayer('track', tileset, 0, 0);
		this.collisionLayer = map.createLayer('wall', tileset, 0, 0);

		if (!this.collisionLayer) {
			console.error('Collision layer "wall" not found.');
			return;
		}

		// Set up collisions
		//this.collisionLayer.setCollisionByProperty({ collides: true });
		this.collisionLayer.setCollisionByExclusion([-1]);

		const scaleFactor = 800 / 2048; // canvas size / map size
		this.cameras.main.setBounds(0, 0, 2048, 2048); // map bounds
		this.cameras.main.setZoom(scaleFactor);

		// Create the car
		this.car = new Car(this, 225, 1560, this.collisionLayer);

		// Add collision between the car and the collision layer
		this.physics.add.collider(this.car, this.collisionLayer);

		const debugGraphics = this.add.graphics().setAlpha(0.75);
		this.collisionLayer.renderDebug(debugGraphics, {
			tileColor: null, // color of non-colliding tiles
			collidingTileColor: new Phaser.Display.Color(243, 134, 48, 255), // Color of colliding tiles
			faceColor: new Phaser.Display.Color(40, 39, 37, 255), // Color of colliding face edges
		});
		groundLayer?.renderDebug(debugGraphics, {
			collidingTileColor: new Phaser.Display.Color(255,0,0,255),
			faceColor: new Phaser.Display.Color(0,255,0,255)
		})

		EventBus.emit('current-scene-ready', this);
	}

	override update(time: number, delta: number): void {
		this.car.update(delta);
	}
}
